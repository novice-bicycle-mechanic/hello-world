// bypassHorseToStart.cpp
// задание из файла warpcore_1586201037.txt
// вариант задания с обходом по замкнутому пути до начальной позиции

#include <iostream>
#include <clocale>
#include <iomanip>
#include <conio.h>

#define N "\n"

using namespace std;


//------------------------------------------------------------------------


const int offset[9][2] =		// смещения следующих ходов относительно текущего поля
								// [9]-номер хода с 1 по 8, 0 - не используется
								// [2]-смещение по вертикали (0) и горизонтали (1)
{
	{0,0},				// пустое значение, когда идти некуда

	{+2,-1},{+2,+1},	// вниз и налево/направо

	{+1,+2},{-1,+2},	// вправо и вниз/вверх

	{-2,+1},{-2,-1},	// вверх и направо/налево

	{-1,-2},{+1,-2}		// влево и вверх/вниз
};


//------------------------------------------------------------------------


int choosingMoveToStart		// функция выбора хода, если ход последний в пути - только к началу пути
(
	int moveNum,			// номер выполненного хода

	int path[][2],			// путь коня по шахматной доске

	int chessboard[][8],	// шахматная доска

	bool defect[]			// массив забракованных ходов из принятых
)
{
	int rating[9]{};		// оценка возможных ходов: 0-неопределено, 1-8-кол-во ходов, 9-занято, 10-тупик, 11-вне границ доски

	int min = 99;			// минимальная оценка хода

	int numMin = 0;			// номер хода с минимальной оценкой

	int row1 = 0;			// номер строки после смещения по возможному ходу относительно текущего поля

	int col1 = 0;			// номер колонки после смещения по возможному ходу относительно текущего поля

	int row2 = 0;			// номер строки после смещения по возможному ходу относительно целевого поля

	int col2 = 0;			// номер колонки после смещения по возможному ходу относительно целевого поля

	if (moveNum == 64)		// если выполненный ход равен 64, то следующий ход №65 должен быть в 1-ю позицию пути
	{
		for (size_t i = 1; i < 9; i++)	// оценка возможных ходов
		{
			row1 = path[moveNum][0] + offset[i][0];

			col1 = path[moveNum][1] + offset[i][1];

			// проверка, что целевое поле в границах шахматной доски

			if (((-1 < row1) && (row1 < 8)) && ((-1 < col1) && (col1 < 8)))
			{
				// проверка, что целевое поле - первое в пути (№1)

				if (chessboard[row1][col1] == 1)
				{
					rating[i] = 1;		// целевое поле (первое в пути) достигнуто
				}
				else
				{
					rating[i] = 12;		// целевое поле (первое в пути) не достигнуто
				}
			}
			else
			{
				rating[i] = 11;		// целевое поле вне границ шахматной доски
			}
		}
	}
	else					// иначе, если выполненный ход не равен (меньше) 64 - обычный порядок анализа
	{
		for (size_t i = 1; i < 9; i++)	// оценка возможных ходов
		{
			row1 = path[moveNum][0] + offset[i][0];

			col1 = path[moveNum][1] + offset[i][1];

			// проверка, что целевое поле в границах шахматной доски

			if (((-1 < row1) && (row1 < 8)) && ((-1 < col1) && (col1 < 8)))
			{
				// проверка, что по целевому полю не ходил конь

				if (chessboard[row1][col1] == 0)
				{
					// подсчет разрешенных возможных ходов относительно целевого поля

					for (size_t j = 0; j < 8; j++)
					{
						row2 = row1 + offset[j][0];

						col2 = col1 + offset[j][1];

						if (((-1 < row2) && (row2 < 8))

							&& ((-1 < col2) && (col2 < 8))

							&& (chessboard[row2][col2] == 0))
						{
							rating[i]++;	// подсчет возможных ходов
						}
					}
				}
				else
				{
					rating[i] = 9;		// целевое поле занято - по нему ходил конь
				}
			}
			else
			{
				rating[i] = 11;		// целевое поле вне границ шахматной доски
			}
		}
	}

	for (size_t i = 1; i < 9; i++)	// пометка текущего номера, как забракованного, если он завел в тупик
	{
		if (defect[i])
		{
			rating[i] = 10;		// при выполнении хода зашли в тупик
		}
	}

	for (size_t i = 1; i < 9; i++)	// нахождение минимальной оценки возможных ходов
	{
		if (min > rating[i])
		{
			min = rating[i];

			numMin = i;
		}
	}

	// возврат номера хода

	if (min < 9)
	{
		return numMin;
	}
	else
	{
		return 0;
	}
}


//------------------------------------------------------------------------


bool nextMoveToStart		// функция выполнения следующего хода вплоть до первого
(
	int moveNumber,			// номер выполненного хода

	int path[][2],			// путь коня по шахматной доске

	int chessboard[][8]		// шахматная доска	
)
{
	bool defect[9]{};		// массив забракованных ходов из принятых (true - если забраковано)

	int numMove = 0;		// номер выбранного хода

	do
	{
		numMove = choosingMoveToStart(moveNumber, path, chessboard, defect);	// номер выбранного хода 

		cout << " " << moveNumber << " " << numMove << endl;

		if (numMove)								// если номер выбранного хода не равен 0
		{
			if (moveNumber < 64)					// если номер выполненного хода меньше предельного (с учетом +1 далее)
			{
				int row = path[moveNumber][0];		// номер строки поля выполненного хода

				int col = path[moveNumber][1];		// номер колонки поля выполненного хода

				moveNumber++;						// номер следующего хода

				path[moveNumber][0] = row + offset[numMove][0];		// номер ряда следующего хода

				path[moveNumber][1] = col + offset[numMove][1];		// номер колонки следующего хода

				chessboard[path[moveNumber][0]][path[moveNumber][1]] = moveNumber;

				if (nextMoveToStart(moveNumber, path, chessboard)) // если результат вызова функции true
				{
					return true;		// - доска вся пройдена - выход из всех функций
				}
				else										// иначе, если результат вызова функции false
				{
					defect[numMove] = true;		// бракуем текущий ход

//					chessboard[path[moveNumber][0]][path[moveNumber][1]] = 0;

					continue;					// и выбираем следующий из оставшихся ход
				}
			}
			else if (moveNumber == 64)	// иначе, если номер выполненного хода равен 64 
			{							// - следующий ход должен быть в первую позицию пути

				int row = path[moveNumber][0];		// номер строки поля выполненного хода

				int col = path[moveNumber][1];		// номер колонки поля выполненного хода

				moveNumber++;						// номер следующего хода

				cout << " qqq " << moveNumber << " " << numMove << endl;

				if (((row + offset[numMove][0]) == path[1][0])		// если номер ряда следующего хода равен
																	//номеру ряда первого хода пути

					&& ((col + offset[numMove][1]) == path[1][1]))	// и, если номер колонки следующего хода
																	// равен номеру колонки первого хода пути
				{
					cout << " true" << endl;

					return true;	// возврат из функции и всех ранее запущенных функций				
				}
				else												// иначе
				{
					cout << " false" << endl;

					chessboard[path[moveNumber][0]][path[moveNumber][1]] = 0;

					return false;	// возврат из функции на предыдущий уровень
				}
			}
			else 
			{
				cout << " false" << endl;

				chessboard[path[moveNumber][0]][path[moveNumber][1]] = 0;

				return false;		// возврат из функции на предыдущий уровень
			}
		}
		else	// иначе, если номер выбранного хода равен 0 - тупик
		{
			cout << " false" << endl;

			chessboard[path[moveNumber][0]][path[moveNumber][1]] = 0;

			return false;		// возврат из функции на предыдущий уровень
		}

	} while (true);
}


//------------------------------------------------------------------------


int main()
{
	setlocale(LC_ALL, "ru");

	//------------------------

	//                     warpcore_1586201037.txt

	// Тема: Функции

	//                            Задание 1

	//     Изучить задачу "Обход конем шахматной доски". Выбрать самый

	// подходящий алгоритм для реализации на компьютере.


	int path[66][2]{};				// путь коня по шахматной доске

	int chessboard[8][8]{};			// шахматная доска

	int byte1char = 0;				// первый байт кода нажатия клавиши символа

	enum key { ESC = 27 };			// коды нажатий клавиш

	bool symbolNumber = 1;			// номер символа в обозначении клетки шахматной доски


	cout
		<< "                     warpcore_1586201037.txt"

		N N" Тема: Функции. Рекурсия."

		N N"                            Задание 1"

		N N"     Изучить задачу \"Обход конем шахматной доски\". Выбрать самый"

		N N" подходящий алгоритм для реализации на компьютере."

		<< N << endl;

	cout
		<< "     Для обхода конем шахматной доски принимаем алгоритм \"Правило"

		N N" Варнсдорфа\": \"При обходе доски конь следует на то поле, с которого"

		N N" можно пойти на минимальное число ещё не пройденных полей. Если"

		N N" таких полей несколько, то можно пойти на любое из них\"."

		N N"     Принимаем, что путь коня замкнут."

		<< N << endl;

	cout
		<< " Укажите поле, с которого начнется обход конем шахматной доски"

		N N" (буква (a,b,c,d,e,f,g,h) и цифра (1-8)) > ";

	// ввод обозначения поля

	do
	{
		byte1char = _getch();

		if (_kbhit()) { (void)_getch(); }

		if (symbolNumber)
		{
			if (((int)('a') <= byte1char) && (byte1char <= (int)('h')))
			{
				path[1][1] = byte1char - (int)('a');

				cout << (char)byte1char;

				symbolNumber = !symbolNumber;

				byte1char = 0;
			}
		}
		else
		{
			if (((int)('1') <= byte1char) && (byte1char <= (int)('8')))
			{
				path[1][0] = 8 - (byte1char - (int)('0'));

				cout << (char)byte1char;

				symbolNumber = !symbolNumber;

				byte1char = 0;

				break;
			}
		}

	} while (true);

	cout << endl;

	chessboard[path[1][0]][path[1][1]] = 1;		// укажем в выбранном поле номер хода

	// обход шахматной доски

	(void)nextMoveToStart(1, path, chessboard);		// функция выполнения ходов

	// вывод шахматной доски на экран

	cout << N N << endl;

	for (size_t i = 0; i < 8; i++)
	{
		cout << setw(15) << (char)(8 - i + (int)('0')) << setw(3) << "|";

		for (size_t j = 0; j < 8; j++)
		{
			cout << setw(4) << chessboard[i][j];
		}

		cout << endl;

		if (i < 7) { cout << setw(18) << "|" << endl; }
	}

	cout << setw(13) << "" << setw(1) << "----+---------------------------------" << endl;

	cout << setw(18) << "|";

	for (size_t i = 0; i < 8; i++)
	{
		cout << setw(4) << (char)(i + (int)('a'));
	}

	cout << N << endl;

	//------------------------

	return 0;
}